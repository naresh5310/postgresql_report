\H
\set filename :DBNAME
\echo Report name and location: /tmp/pg_collector_:filename.html
\o /tmp/pg_collector_:filename.html
\pset footer  off
\qecho <style type='text/css'>
\qecho body {
\qecho font:10pt Arial,Helvetica,sans-serif;
\qecho color:Black; background:white; }
\qecho p {
\qecho font:10pt Arial,sans-serif;
\qecho color:Black; background:White; }
\qecho table {
\qecho font:10pt Arial,Helvetica,sans-serif;
\qecho text-align:center;
\qecho color:Black; background:White;
\qecho padding:0px 0px 0px 0px; margin:0px 0px 0px 0px; }
\qecho tr {
\qecho font:10pt Arial,Helvetica,sans-serif;
\qecho text-align:center;
\qecho color:Black; background:White;
\qecho padding:0px 0px 0px 0px; margin:0px 0px 0px 0px; }
\qecho td {
\qecho font:10pt Arial,Helvetica,sans-serif;
\qecho text-align:center;
\qecho color:Black; background:#FFFFE0;
\qecho padding:0px 0px 0px 0px; margin:0px 0px 0px 0px; }
\qecho th {
\qecho font:bold 10pt Arial,Helvetica,sans-serif;
\qecho color:#FFFFFF;
\qecho background:#0066CC;
\qecho padding:0px 0px 0px 0px;}
\qecho h1 {
\qecho font:bold 16pt Arial,Helvetica,Geneva,sans-serif;
\qecho color:#336699;
\qecho background-color:#0066CC;
\qecho border-bottom:1px solid #0066CC;
\qecho margin-top:0pt; margin-bottom:0pt; padding:0px 0px 0px 0px;}
\qecho h2 {
\qecho font:bold 10pt Arial,Helvetica,Geneva,sans-serif;
\qecho color:#336699;
\qecho background-color:White;
\qecho margin-top:4pt; margin-bottom:0pt;}
\qecho h3 {
\qecho font:bold 10pt Arial,Helvetica,Geneva,sans-serif;
\qecho color:#336699;
\qecho background-color:White;
\qecho margin-top:4pt; margin-bottom:0pt;}
\qecho a {
\qecho font:9pt Arial,Helvetica,sans-serif;
\qecho color:#663300;
\qecho background:#ffffff;
\qecho margin-top:0pt; margin-bottom:0pt; vertical-align:top;}
\qecho .threshold-critical {
\qecho font:bold 10pt Arial,Helvetica,sans-serif;
\qecho color:red; }
\qecho .threshold-warning {
\qecho font:bold 10pt Arial,Helvetica,sans-serif;
\qecho color:orange; }
\qecho .threshold-ok {
\qecho font:bold 10pt Arial,Helvetica,sans-serif;
\qecho color:green; }
\qecho </style>
\qecho <h1 align="center" style="background-color:#0066CC;color:White" >CloudSQL PostgreSQL Report </h1>
\qecho <br>
\qecho 'PG Host Name : ':HOST
\qecho <br>
\set QUIET 1
select case when count(*)=0 then 'select ''not-aurora'' as avers'
                            else 'select aurora_version() as avers'
       end as aurora_version_query
from pg_settings where name='rds.extensions' and setting like '%aurora_stat_utils%' \gset
prepare detect_aurora as :aurora_version_query;
execute detect_aurora \gset
deallocate detect_aurora;
with
  pgvers as (
    select current_setting('server_version') as v
  ), allvers as (
    select 1 priority, 'Aurora-'||v||'-'||:'avers' as version from pgvers
    where :'avers' <> 'not-aurora'
      union all
    select 2, 'RDS-'||v from pgvers, pg_settings s
    where s.name like 'rds.%'
      union all
    select 3, 'pg-'||v from pgvers
  )
select first_value(version) over (order by priority) as server_version
from allvers limit 1 \gset
select case when pg_is_in_recovery() then 'Standby/Reader DB (Read Only)' else 'Primary/writer DB (Read write)' end as standby_mode \gset
\unset QUIET
\qecho :server_version
\qecho :standby_mode
\qecho <br>
\qecho <br>
select  now () as "Date" ,pg_postmaster_start_time() as "DB_START_DATE", current_timestamp - pg_postmaster_start_time() as "UP_TIME"  ,current_database() as "DB_connected" ,current_user USER_NAME,inet_server_port() as "DB_PORT ",version()  as "DB_Version" , setting AS block_size FROM pg_settings WHERE name = 'block_size';
\qecho <br>
\qecho <br>
\l+

\qecho <br>
\qecho <a  name="0"></a>
\qecho <h2>
\qecho Main Report
\qecho </h2><ul>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#0">Main Report</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#1">Table and Index statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#2">Database, User and Schema Statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#3">Configuration Statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#4">Replication Statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#5">Vacuum and Wraparound Statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#6">Extension Statistics</a></li>
\qecho <li nowrap align="left" width="25%"><a class="link" href="#7">Current Workload Statistics</a></li>
-- \qecho <li nowrap align="left" width="25%"><a class="link" href="#8">Others</a></li>
\qecho </ul>
\qecho <br /><a  href="#0">Back to Main</a><hr /><p />
\qecho <a  name="1"></a>
\qecho <h2>
\qecho Table and Index statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#Table_Size">Table Statistics</a</li>
\qecho <li ><a  href="#index_Size">Index Statistics</a</li>
\qecho <li ><a  href="#Fragmentation">Table Fragmentation </a</li>
-- \qecho <li ><a  href="#Unused_Indexes">Unused Indexes</a</li>
-- \qecho <li ><a  href="#Duplicate_indexes">Duplicate indexes</a</li>
--\qecho <li ><a  href="#table_Access_Profile">Table Access Profile</a</li>
--\qecho <li ><a  href="#Index_Access_Profile">Index Access Profile</a</li>
\qecho <li ><a  href="#Toast_Tables_Mapping">Toast Tables Mapping</a</li>
-- \qecho <li ><a  href="#PK_FK_using_numeric_or_integer_data_type">PK or FK using numeric or integer data type</a</li>
\qecho <li ><a  href="#unlogged_tables">Unlogged Tables</a</li>
\qecho <li ><a  href="#Temp_tables">Temp tables</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <a  name="2"></a>
\qecho <h2>
\qecho Database, User and Schema Statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#Database_size">Database size</a</li>
\qecho <li ><a  href="#Users_Roles_Info">Users & Roles Info</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#2">Back to Database, User and Schema Statistics</a>
\qecho <a  name="3"></a>
\qecho <h2>
\qecho Configuration Statistics
\qecho </h2>
\qecho <ul>
-- \qecho <li ><a  href="#DB_parameters">DB parameters</a</li>
\qecho <li ><a  href="#Memory_setting">Memory setting</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#3">Back to Configuration Statistics</a>
\qecho <a  name="4"></a>
\qecho <h2>
\qecho Replication Statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#Replication">Replication</a</li>
\qecho <li ><a  href="#Orphaned_prepared_transactions">Orphaned prepare transactions</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#4">Back to Replication Statistics</a>
\qecho <a  name="5"></a>
\qecho <h2>
\qecho Vacuum and Wraparound Statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#vacuum_Statistics">Vacuum & Statistics</a</li>
\qecho <li ><a  href="#Transaction_ID_TXID">Transaction ID TXID</a</li>
\qecho <li ><a  href="#Multixact_ID_MXID">Multixact ID MXID</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#5">Back to Vacuum and Wraparound Statistics</a>
\qecho <a  name="6"></a>
\qecho <h2>
\qecho Extension Statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#pg_stat_statements_extension">pg_stat_statements extension</a</li>
\qecho <li ><a  href="#pgaudit_extension">pgaudit extension</a</li>
\qecho <li ><a  href="#Extensions">Extensions</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#6">Back to Extension Statistics</a>
\qecho <a  name="7"></a>
\qecho <h2>
\qecho Current Workload Statistics
\qecho </h2>
\qecho <ul>
\qecho <li ><a  href="#sessions_info">Sessions/Connections Info</a</li>
\qecho <li ><a  href="#DB_Load">DB Load</a</li>
\qecho </ul>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#7">Back to Current Workload Statistics</a>


\qecho <br>
\qecho <br>


-- +----------------------------------------------------------------------------+
-- |      - Table_Size                                   -                  |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="Table_Size"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Table Statistics</b></font><hr align="left" width="460">
\qecho <br>
\qecho <h3>Table Size order by schema name and table size:</h3>
\qecho <br>
\qecho <details>
SELECT *, pg_size_pretty(total_bytes) AS TOTAL_PRETTY
    , pg_size_pretty(index_bytes) AS INDEX_PRETTY
    , pg_size_pretty(toast_bytes) AS TOAST_PRETTY
    , pg_size_pretty(table_bytes) AS TABLE_PRETTY
  FROM (
  SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS TABLE_BYTES FROM (
      SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME
              , c.reltuples::bigint AS ROW_ESTIMATE
              , pg_total_relation_size(c.oid) AS TOTAL_BYTES
              , pg_indexes_size(c.oid) AS INDEX_BYTES
              , pg_total_relation_size(reltoastrelid) AS TOAST_BYTES
          FROM pg_class c
          LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE relkind = 'r'
  ) a
) a
order by 2,8 desc;
\qecho </details>
\qecho <br>
\qecho <h3>biggest 50 tables in the DB: </h3>
\qecho <br>
\qecho <details>
SELECT *, pg_size_pretty(total_bytes) AS TOTAL_PRETTY
    , pg_size_pretty(index_bytes) AS INDEX_PRETTY
    , pg_size_pretty(toast_bytes) AS TOAST_PRETTY
    , pg_size_pretty(table_bytes) AS TABLE_PRETTY
  FROM (
  SELECT *, total_bytes-index_bytes-COALESCE(toast_bytes,0) AS TABLE_BYTES FROM (
      SELECT c.oid,nspname AS table_schema, relname AS TABLE_NAME
              , c.reltuples::bigint AS ROW_ESTIMATE
              , pg_total_relation_size(c.oid) AS TOTAL_BYTES
              , pg_indexes_size(c.oid) AS INDEX_BYTES
              , pg_total_relation_size(reltoastrelid) AS TOAST_BYTES
          FROM pg_class c
          LEFT JOIN pg_namespace n ON n.oid = c.relnamespace
          WHERE relkind = 'r'
  ) a
) a
order by 5 desc
LIMIT 50;
\qecho </details>
\qecho <br>
\qecho <h3> Table Access Profile</h3>
\qecho <br>
\qecho <details>
with table_size_info as
(SELECT
schemaname as schema_name,relname as "Table",
pg_relation_size(relid) relation_size,
relid,
pg_size_pretty(pg_relation_size(relid)) AS "table_size",
pg_size_pretty(pg_total_relation_size(relid)) AS "TABLE size + indexes",
pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) as "indexes size"
FROM pg_catalog.pg_statio_all_tables ORDER BY 1,3  desc)
Select
b.schema_name,
a.relname as "Table_Name",
b.table_size as "Table_Size",
a.seq_scan  total_fts_scan ,
a.seq_tup_read total_fts_num_rows_reads,
a.seq_tup_read/NULLIF(a.seq_scan,0)  fts_rows_per_read ,
a.idx_scan total_idx_scan,
a.idx_tup_fetch total_Idx_num_rows_read ,
a.idx_tup_fetch/NULLIF(a.idx_scan,0)  idx_rows_per_read,
trunc((idx_scan::numeric/NULLIF((idx_scan::numeric+seq_scan::numeric),0)) * 100,2) as "IDX_scan_%",
trunc((seq_scan::numeric/NULLIF((idx_scan::numeric+seq_scan::numeric),0)) * 100,2) as "FTS_scan_%",
case when seq_scan>idx_scan then 'FTS' else 'IDX' end access_profile,
a.n_live_tup,
a.n_dead_tup,
trunc((n_dead_tup::numeric/NULLIF(n_live_tup::numeric,0)) * 100,2) as "dead_tup_%",
a.n_tup_ins,
a.n_tup_upd,
a.n_tup_del,
trunc((n_tup_ins::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_ins_%",
trunc((n_tup_upd::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_upd_%",
trunc((n_tup_del::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_del_%"
from pg_stat_all_tables  a ,  table_size_info  b
where a.relid=b.relid
and schema_name not in ('pg_catalog')
order  by b.relation_size  desc;
\qecho </details>
\qecho <br>
\qecho <h3> Tables have more full table scan than index scan : </h3>
\qecho <br>
\qecho <details>
with table_size_info as
(SELECT
schemaname as schema_name,relname as "Table",
pg_relation_size(relid) relation_size,
relid,
pg_size_pretty(pg_relation_size(relid)) AS "table_size",
pg_size_pretty(pg_total_relation_size(relid)) AS "TABLE size + indexes",
pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) as "indexes size"
FROM pg_catalog.pg_statio_all_tables ORDER BY 1,3  desc)
Select
b.schema_name,
a.relname as "Table_Name",
b.table_size as "Table_Size",
a.seq_scan  total_fts_scan ,
a.seq_tup_read total_fts_num_rows_reads,
a.seq_tup_read/NULLIF(a.seq_scan,0)  fts_rows_per_read ,
a.idx_scan total_idx_scan,
a.idx_tup_fetch total_Idx_num_rows_read ,
a.idx_tup_fetch/NULLIF(a.idx_scan,0)  idx_rows_per_read,
trunc((idx_scan::numeric/NULLIF((idx_scan::numeric+seq_scan::numeric),0)) * 100,2) as "IDX_scan_%",
trunc((seq_scan::numeric/NULLIF((idx_scan::numeric+seq_scan::numeric),0)) * 100,2) as "FTS_scan_%",
case when seq_scan>idx_scan then 'FTS' else 'IDX' end access_profile,
a.n_live_tup,
a.n_dead_tup,
trunc((n_dead_tup::numeric/NULLIF(n_live_tup::numeric,0)) * 100,2) as "dead_tup_%",
a.n_tup_ins,
a.n_tup_upd,
a.n_tup_del,
trunc((n_tup_ins::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_ins_%",
trunc((n_tup_upd::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_upd_%",
trunc((n_tup_del::numeric/NULLIF((n_tup_ins::numeric+n_tup_upd::numeric+n_tup_del::numeric),0)) * 100,2) as "tup_del_%"
from pg_stat_all_tables  a ,  table_size_info  b
where a.relid=b.relid
and schema_name not in ('pg_catalog', 'pg_toast')
and seq_scan>idx_scan
and b.relation_size > 10485760
order by b.relation_size desc;
\qecho </details>
\qecho <br>
-- \qecho <h4> pg_statio_all_tables View : </h4>
-- \qecho <h4> Total physical reads (disk blocks read or Reads from Disk) = heap_blks_read + idx_blks_read + toast_blks_read + tidx_blks_read  </h4>
-- \qecho <h4> Total logical reads (buffer hits or Read from Memory)  = heap_blks_hits + idx_blks_hits + toast_blks_hits + tidx_blks_hits  </h4>
\qecho <br>
\qecho <h3> Top 50 Tables by total physical reads : </h3>
\qecho <br>
\qecho <details>
select
s2.* ,
coalesce(trunc((s2.total_physical_reads::numeric/NULLIF((s2.total_physical_reads::numeric+s2.total_logical_reads::numeric),0)) * 100,2),0)  as physical_reads_percent,
coalesce(trunc((s2.total_logical_reads::numeric/NULLIF((s2.total_physical_reads::numeric+s2.total_logical_reads::numeric),0)) * 100,2),0)  as logical_reads_percent
from
(
select
s.* ,
s.table_disk_blocks_read+
s.indexes_disk_blocks_read+
s.TOAST_table_disk_blocks_read+
s.TOAST_indexes_disk_blocks_read as total_physical_reads,

s.table_buffer_hits+
s.indexes_buffer_hits+
s.TOAST_table_buffer_hits+
s.TOAST_indexes_buffer_hits as total_logical_reads
from
(
select
schemaname as schema_name,
relname as table_name,
coalesce(heap_blks_read,0) table_disk_blocks_read ,
coalesce(heap_blks_hit,0)  table_buffer_hits ,
coalesce(idx_blks_read,0) indexes_disk_blocks_read ,
coalesce(idx_blks_hit,0)   indexes_buffer_hits ,
coalesce(toast_blks_read,0) TOAST_table_disk_blocks_read ,
coalesce(toast_blks_hit,0)  TOAST_table_buffer_hits ,
coalesce(tidx_blks_read,0)  TOAST_indexes_disk_blocks_read ,
coalesce(tidx_blks_hit,0)   TOAST_indexes_buffer_hits
from pg_statio_all_tables
where schemaname not in ('pg_toast','pg_catalog','information_schema')
 ) as s

) as s2
order by s2.total_physical_reads  desc limit 50 ;
\qecho </details
\qecho <br>
\qecho <br>
\qecho <h3> Top 50 Tables by total physical reads percent  : </h3>
\qecho <br>
\qecho <details>
select
s2.* ,
coalesce(trunc((s2.total_physical_reads::numeric/NULLIF((s2.total_physical_reads::numeric+s2.total_logical_reads::numeric),0)) * 100,2),0)  as physical_reads_percent,
coalesce(trunc((s2.total_logical_reads::numeric/NULLIF((s2.total_physical_reads::numeric+s2.total_logical_reads::numeric),0)) * 100,2),0)  as logical_reads_percent
from
(
select
s.* ,
s.table_disk_blocks_read+
s.indexes_disk_blocks_read+
s.TOAST_table_disk_blocks_read+
s.TOAST_indexes_disk_blocks_read as total_physical_reads,

s.table_buffer_hits+
s.indexes_buffer_hits+
s.TOAST_table_buffer_hits+
s.TOAST_indexes_buffer_hits as total_logical_reads
from
(
select
schemaname as schema_name,
relname as table_name,
coalesce(heap_blks_read,0) table_disk_blocks_read ,
coalesce(heap_blks_hit,0)  table_buffer_hits ,
coalesce(idx_blks_read,0) indexes_disk_blocks_read ,
coalesce(idx_blks_hit,0)   indexes_buffer_hits ,
coalesce(toast_blks_read,0) TOAST_table_disk_blocks_read ,
coalesce(toast_blks_hit,0)  TOAST_table_buffer_hits ,
coalesce(tidx_blks_read,0)  TOAST_indexes_disk_blocks_read ,
coalesce(tidx_blks_hit,0)   TOAST_indexes_buffer_hits
from pg_statio_all_tables
where schemaname not in ('pg_toast','pg_catalog','information_schema')
) as s

) as s2
order by physical_reads_percent  desc limit 50  ;
\qecho </details>
\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - index_Size                                    -                  |
-- +----------------------------------------------------------------------------+
\qecho <br>

\qecho <a name="index_Size"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Index Statistics</b></font><hr align="left" width="460">
\qecho <br>
\qecho <h3>Index Size order by schema name and table name :</h3>
\qecho <br>
\qecho <details>
SELECT
schemaname,relname as "Table",
indexrelname AS indexname,
pg_relation_size(indexrelid),
pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_catalog.pg_statio_all_indexes  ORDER BY 1,2 desc ;
\qecho </details>
\qecho <br>
\qecho <h3>biggest 50 Index in the DB :</h3>
\qecho <br>
\qecho <details>
SELECT
schemaname,relname as "Table",
indexrelname AS indexname,
pg_relation_size(indexrelid),
pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_catalog.pg_statio_all_indexes  ORDER BY 4 desc limit 50;
\qecho </details>

\qecho <br>
\qecho <h3>Index Size order by schema name and table name :</h3>
\qecho <br>
\qecho <details>

SELECT ai.schemaname,ai.relname AS tablename,ai.indexrelid  as index_oid ,
ai.indexrelname AS indexname,i.indisunique ,
ai.idx_scan ,
pg_relation_size(ai.indexrelid) as index_size,
pg_size_pretty(pg_relation_size(ai.indexrelid)) AS pretty_index_size
FROM pg_catalog.pg_stat_all_indexes ai , pg_index i
WHERE ai.indexrelid=i.indexrelid
and ai.idx_scan = 0
and ai.schemaname not in ('pg_catalog')
order by index_size desc;
\qecho </details>

\qecho <br>
\qecho <h3>Duplicate Indexes</h3>
\qecho <br>
\qecho <details>
SELECT pg_size_pretty(sum(pg_relation_size(idx))::bigint) as size,
       (array_agg(idx))[1] as idx1, (array_agg(idx))[2] as idx2,
       (array_agg(idx))[3] as idx3, (array_agg(idx))[4] as idx4
FROM (
    SELECT indexrelid::regclass as idx, (indrelid::text ||E'\n'|| indclass::text ||E'\n'|| indkey::text ||E'\n'||
                                         coalesce(indexprs::text,'')||E'\n' || coalesce(indpred::text,'')) as key
    FROM pg_index) sub
GROUP BY key HAVING count(*)>1
ORDER BY sum(pg_relation_size(idx)) DESC;

\qecho </details>


\qecho <br>
\qecho <h3>Index Access Profile :</h3>
\qecho <br>
\qecho <details>

with index_size_info as
(
SELECT
schemaname,relname as "Table",
indexrelname AS indexname,
indexrelid,
pg_relation_size(indexrelid) index_size_byte,
pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_catalog.pg_statio_all_indexes  ORDER BY 1,4 desc)
Select a.schemaname,
a.relname as "Table_Name",
a.indexrelname AS indexname,
b.index_size,
a.idx_scan,
a.idx_tup_read,
a.idx_tup_fetch
from pg_stat_all_indexes a ,  index_size_info b
where a.idx_scan >0
and a.indexrelid=b.indexrelid
and a.schemaname not in ('pg_catalog')
order by b.index_size_byte desc,a.idx_scan asc ;
\qecho </details>
\qecho <br>
-- \qecho <h4> pg_statio_all_indexes  View : </h4>
-- \qecho <h4> physical reads (disk blocks read or Reads from Disk) = idx_blks_read  </h4>
-- \qecho <h4> logical reads (buffer hits or Read from Memory) = idx_blks_hit  </h4>
\qecho <br>
\qecho <h3> Top 50 index by physical reads : </h3>
\qecho <br>
\qecho <details>
select
schemaname        as schema_name  ,
relname            as table_name     ,
indexrelname    as index_name,
coalesce(idx_blks_read,0)   as indexe_disk_blocks_read,
coalesce(idx_blks_hit,0)    as indexe_buffer_hits    ,
coalesce(trunc((coalesce(idx_blks_read,0)
/
NULLIF(
coalesce(idx_blks_read,0)
+coalesce(idx_blks_hit,0)
,0) ) * 100,2),0) as physical_reads_percent ,
coalesce(trunc((coalesce(idx_blks_hit,0)
/
NULLIF(
coalesce(idx_blks_read,0)
+coalesce(idx_blks_hit,0)
,0) ) * 100,2),0) as logical_reads_percent
from
pg_statio_all_indexes
where schemaname not in ('pg_toast','pg_catalog','information_schema')
order by indexe_disk_blocks_read desc limit 50 ;
\qecho </details>
\qecho <br>
\qecho <h3> Top 50 index by physical reads percent  : </h3>
\qecho <br>
\qecho <details>
select
schemaname        as schema_name  ,
relname            as table_name     ,
indexrelname    as index_name,
coalesce(idx_blks_read,0)   as indexe_disk_blocks_read,
coalesce(idx_blks_hit,0)    as indexe_buffer_hits    ,
coalesce(trunc((coalesce(idx_blks_read,0)
/
NULLIF(
coalesce(idx_blks_read,0)
+coalesce(idx_blks_hit,0)
,0) ) * 100,2),0) as physical_reads_percent ,
coalesce(trunc((coalesce(idx_blks_hit,0)
/
NULLIF(
coalesce(idx_blks_read,0)
+coalesce(idx_blks_hit,0)
,0) ) * 100,2),0) as logical_reads_percent
from
pg_statio_all_indexes
where schemaname not in ('pg_toast','pg_catalog','information_schema')
order by physical_reads_percent desc limit 50 ;
\qecho </details>

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>

-- +----------------------------------------------------------------------------+
-- |      - Fragmentation                                    -                  |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="Fragmentation"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Fragmentation (Bloat)</b></font><hr align="left" width="460">
-- Show database bloat
\qecho <br>
\qecho <h3>Tables and indexes Bloat [Fragmentation] order by table wasted size :</h3>
\qecho <br>
\qecho <details>
SELECT
  current_database(), schemaname, tablename, /*reltuples::bigint, relpages::bigint, otta,*/
  ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::FLOAT/otta END)::NUMERIC,1) AS "table_bloat_%",
  CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes,
  pg_size_pretty(CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END) AS table_wasted_size,
  iname AS Index_nam, /*ituples::bigint, ipages::bigint, iotta,*/
  ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::FLOAT/iotta END)::NUMERIC,1) AS "Index_bloat_%",
  CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes,
  pg_size_pretty(CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) ::BIGINT END) AS Index_wasted_size
FROM (
  SELECT
    schemaname, tablename, cc.reltuples, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::FLOAT)) AS otta,
    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::FLOAT)),0) AS iotta -- very rough approximation, assumes all cols
  FROM (
    SELECT
      ma,bs,schemaname,tablename,
      (datawidth+(hdr+ma-(CASE WHEN hdr%ma=0 THEN ma ELSE hdr%ma END)))::NUMERIC AS datahdr,
      (maxfracsum*(nullhdr+ma-(CASE WHEN nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
    FROM (
      SELECT
        schemaname, tablename, hdr, ma, bs,
        SUM((1-null_frac)*avg_width) AS datawidth,
        MAX(null_frac) AS maxfracsum,
        hdr+(
          SELECT 1+COUNT(*)/8
          FROM pg_stats s2
          WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
        ) AS nullhdr
      FROM pg_stats s, (
        SELECT
          (SELECT current_setting('block_size')::NUMERIC) AS bs,
          CASE WHEN SUBSTRING(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,
          CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma
        FROM (SELECT version() AS v) AS foo
      ) AS constants
      GROUP BY 1,2,3,4,5
    ) AS foo
  ) AS rs
  JOIN pg_class cc ON cc.relname = rs.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname <> 'information_schema'
  LEFT JOIN pg_index i ON indrelid = cc.oid
  LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid
) AS sml
ORDER BY wastedbytes DESC;
\qecho </details>

\qecho <br>
\qecho <h3>Tables and indexes Bloat [Fragmentation] order by table wasted % :</h3>
\qecho <br>
\qecho <details>
SELECT
  current_database(), schemaname, tablename, /*reltuples::bigint, relpages::bigint, otta,*/
  ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::FLOAT/otta END)::NUMERIC,1) AS "table_bloat_%",
  CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes,
  pg_size_pretty(CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END) AS table_wasted_size,
  iname AS Index_nam, /*ituples::bigint, ipages::bigint, iotta,*/
  ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::FLOAT/iotta END)::NUMERIC,1) AS "Index_bloat_%",
  CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes,
  pg_size_pretty(CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) ::BIGINT END) AS Index_wasted_size
FROM (
  SELECT
    schemaname, tablename, cc.reltuples, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::FLOAT)) AS otta,
    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::FLOAT)),0) AS iotta -- very rough approximation, assumes all cols
  FROM (
    SELECT
      ma,bs,schemaname,tablename,
      (datawidth+(hdr+ma-(CASE WHEN hdr%ma=0 THEN ma ELSE hdr%ma END)))::NUMERIC AS datahdr,
      (maxfracsum*(nullhdr+ma-(CASE WHEN nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
    FROM (
      SELECT
        schemaname, tablename, hdr, ma, bs,
        SUM((1-null_frac)*avg_width) AS datawidth,
        MAX(null_frac) AS maxfracsum,
        hdr+(
          SELECT 1+COUNT(*)/8
          FROM pg_stats s2
          WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
        ) AS nullhdr
      FROM pg_stats s, (
        SELECT
          (SELECT current_setting('block_size')::NUMERIC) AS bs,
          CASE WHEN SUBSTRING(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,
          CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma
        FROM (SELECT version() AS v) AS foo
      ) AS constants
      GROUP BY 1,2,3,4,5
    ) AS foo
  ) AS rs
  JOIN pg_class cc ON cc.relname = rs.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname <> 'information_schema'
  LEFT JOIN pg_index i ON indrelid = cc.oid
  LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid
) AS sml
ORDER BY 4 desc;
\qecho </details>
\qecho <br>
\qecho <h3>Tables and indexes Bloat [Fragmentation] order by index wasted % :</h3>
\qecho <br>
\qecho <details>
SELECT
  current_database(), schemaname, tablename, /*reltuples::bigint, relpages::bigint, otta,*/
  ROUND((CASE WHEN otta=0 THEN 0.0 ELSE sml.relpages::FLOAT/otta END)::NUMERIC,1) AS "table_bloat_%",
  CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END AS wastedbytes,
  pg_size_pretty(CASE WHEN relpages < otta THEN 0 ELSE bs*(sml.relpages-otta)::BIGINT END) AS table_wasted_size,
  iname AS Index_nam, /*ituples::bigint, ipages::bigint, iotta,*/
  ROUND((CASE WHEN iotta=0 OR ipages=0 THEN 0.0 ELSE ipages::FLOAT/iotta END)::NUMERIC,1) AS "Index_bloat_%",
  CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) END AS wastedibytes,
  pg_size_pretty(CASE WHEN ipages < iotta THEN 0 ELSE bs*(ipages-iotta) ::BIGINT END) AS Index_wasted_size
FROM (
  SELECT
    schemaname, tablename, cc.reltuples, cc.relpages, bs,
    CEIL((cc.reltuples*((datahdr+ma-
      (CASE WHEN datahdr%ma=0 THEN ma ELSE datahdr%ma END))+nullhdr2+4))/(bs-20::FLOAT)) AS otta,
    COALESCE(c2.relname,'?') AS iname, COALESCE(c2.reltuples,0) AS ituples, COALESCE(c2.relpages,0) AS ipages,
    COALESCE(CEIL((c2.reltuples*(datahdr-12))/(bs-20::FLOAT)),0) AS iotta -- very rough approximation, assumes all cols
  FROM (
    SELECT
      ma,bs,schemaname,tablename,
      (datawidth+(hdr+ma-(CASE WHEN hdr%ma=0 THEN ma ELSE hdr%ma END)))::NUMERIC AS datahdr,
      (maxfracsum*(nullhdr+ma-(CASE WHEN nullhdr%ma=0 THEN ma ELSE nullhdr%ma END))) AS nullhdr2
    FROM (
      SELECT
        schemaname, tablename, hdr, ma, bs,
        SUM((1-null_frac)*avg_width) AS datawidth,
        MAX(null_frac) AS maxfracsum,
        hdr+(
          SELECT 1+COUNT(*)/8
          FROM pg_stats s2
          WHERE null_frac<>0 AND s2.schemaname = s.schemaname AND s2.tablename = s.tablename
        ) AS nullhdr
      FROM pg_stats s, (
        SELECT
          (SELECT current_setting('block_size')::NUMERIC) AS bs,
          CASE WHEN SUBSTRING(v,12,3) IN ('8.0','8.1','8.2') THEN 27 ELSE 23 END AS hdr,
          CASE WHEN v ~ 'mingw32' THEN 8 ELSE 4 END AS ma
        FROM (SELECT version() AS v) AS foo
      ) AS constants
      GROUP BY 1,2,3,4,5
    ) AS foo
  ) AS rs
  JOIN pg_class cc ON cc.relname = rs.tablename
  JOIN pg_namespace nn ON cc.relnamespace = nn.oid AND nn.nspname = rs.schemaname AND nn.nspname <> 'information_schema'
  LEFT JOIN pg_index i ON indrelid = cc.oid
  LEFT JOIN pg_class c2 ON c2.oid = i.indexrelid
) AS sml
ORDER BY 8 desc;
\qecho </details>

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - Toast_Tables_Mapping                                  -                  |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="Toast_Tables_Mapping"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Toast Tables Mapping</b></font><hr align="left" width="460">
\qecho <br>

select t.relname table_name, r.relname toast_name, pg_size_pretty(pg_relation_size(t.reltoastrelid)) as toast_size
FROM
    pg_class r
INNER JOIN pg_class t ON r.oid = t.reltoastrelid
order by r.relname ;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - unlogged_tables                                    -                |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="unlogged_tables"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Unlogged Tables</b></font><hr align="left" width="460">
\qecho <br>

\qecho <h3>Number of Unlogged Tables : </h3>
select count (*) FROM pg_class WHERE relpersistence = 'u';
\qecho <br>
select relname as table_name, relpersistence FROM pg_class WHERE relpersistence = 'u';


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>


-- +----------------------------------------------------------------------------+
-- |      - Temp tables                                      -                  |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="Temp_tables"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Temp tables</b></font><hr align="left" width="460">

\qecho <br>

\qecho <h3>Parameters:</h3>

select
name as parameter_name,setting,unit,short_desc
FROM pg_catalog.pg_settings
WHERE name in ('temp_tablespaces','temp_file_limit','log_temp_files' ) ;
\qecho <br>
select name as parameter_name, setting , unit,   (((setting::BIGINT)*8)/1024)::BIGINT  as "size_MB" ,(((setting::BIGINT)*8)/1024/1024)::BIGINT  as "size_GB", pg_size_pretty((((setting::BIGINT)*8)*1024)::BIGINT),short_desc
from pg_settings where name in ('temp_buffers') ;
\qecho <br>
\qecho <h3>Temp tables statistics:</h3>
\qecho <h4>Note: Number of temporary files created by queries in every Database and total amount of data written to temporary files by queries in every Database </h4>
\qecho <br>
select datname as database_name, temp_bytes/1024/1024 temp_size_MB,
temp_bytes/1024/1024/1024 temp_size_GB ,temp_files  from  pg_stat_database
where  temp_bytes + temp_files > 0
and datname is not null
order by 2  desc;

\qecho <br>
SELECT
n.nspname as SchemaName
,c.relname as RelationName
,CASE c.relkind
WHEN 'r' THEN 'table'
WHEN 'v' THEN 'view'
WHEN 'i' THEN 'index'
WHEN 'S' THEN 'sequence'
WHEN 's' THEN 'special'
END as RelationType
,pg_catalog.pg_get_userbyid(c.relowner) as RelationOwner
,pg_size_pretty(pg_relation_size(n.nspname ||'.'|| c.relname)) as RelationSize
FROM pg_catalog.pg_class c
LEFT JOIN pg_catalog.pg_namespace n
ON n.oid = c.relnamespace
WHERE c.relkind IN ('r','s')
AND (n.nspname !~ '^pg_toast' and nspname like 'pg_temp%')
ORDER BY pg_relation_size(n.nspname ||'.'|| c.relname) DESC ;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#1">Back to Table and Index Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - Database_size                                    -                  |
-- +----------------------------------------------------------------------------+
\qecho <br>
\qecho <a name="Database_size"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Database size</b></font><hr align="left" width="460">
SELECT pg_database.datname Database_Name , pg_size_pretty(pg_database_size(pg_database.datname)) AS Database_Size FROM pg_database;

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#2">Back to Database, User and Schema Statistics</a>
\qecho <br>

-- +----------------------------------------------------------------------------+
-- |      - Users_Roles_Info                                  -                  |
-- +----------------------------------------------------------------------------+

\qecho <br>
\qecho <a name="Users_Roles_Info"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Users & Roles Info</b></font><hr align="left" width="460">
\qecho <br>

\du
\qecho <br>
-- list of per database role settings (settings set at the role level)
\drds
\qecho <br>
select * FROM pg_user;



\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#2">Back to Database, User and Schema Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - DB_parameters                                    -                  |
-- +----------------------------------------------------------------------------+

-- \qecho <a name="DB_parameters"></a>
-- \qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>DB parameters</b></font><hr align="left" width="460">
-- \qecho <br>

-- SELECT *  FROM pg_settings where name not in ('rds.extensions') order by category;
-- SELECT *  FROM pg_settings where name in ('rds.extensions') order by category;


-- \qecho <br>
-- \qecho <a  href="#0">Back to Main</a><p />
-- \qecho <a  href="#3">Back to Configuration Statistics</a>
-- \qecho <br>


-- +----------------------------------------------------------------------------+
-- |      - Memory setting                                   -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="Memory_setting"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Memory setting</b></font><hr align="left" width="460">
\qecho <br>

(
select name as parameter_name , setting , unit, (setting::BIGINT/1024)::BIGINT  as "size_MB" ,(setting::BIGINT/1024/1024)::BIGINT  as "size_GB" ,  pg_size_pretty((setting::BIGINT*1024)::BIGINT)
from pg_settings where name in ('work_mem','maintenance_work_mem')
)
UNION ALL
(
select name as parameter_name, setting , unit , (((setting::BIGINT)*8)/1024)::BIGINT  as "size_MB" ,(((setting::BIGINT)*8)/1024/1024)::BIGINT  as "size_GB", pg_size_pretty((((setting::BIGINT)*8)*1024)::BIGINT)
from pg_settings where name in ('shared_buffers','wal_buffers','effective_cache_size','temp_buffers')
) order by 4  desc;

select name as parameter_name,setting  FROM pg_catalog.pg_settings WHERE name in ('huge_pages' ) ;
\qecho <br>
\qecho cach read hit for the whole instance
select
round((sum(blks_hit)::numeric / (sum(blks_hit) + sum(blks_read)::numeric))*100,2) as cache_read_hit_percentage
from pg_stat_database ;
\qecho <br>
\qecho cach read hit per Database
select datname as database_name,
round((blks_hit::numeric / (blks_hit + blks_read)::numeric)*100,2) as cache_read_hit_percentage
from pg_stat_database
where blks_hit + blks_read > 0
and datname is not null
order by 2 desc;

\qecho <br>
\qecho cach read hit per table
\qecho <br>

SELECT schemaname,relname as table_name,
 round((heap_blks_hit::numeric / (heap_blks_hit + heap_blks_read)::numeric)*100,2) as read_hit_percentage
FROM
  pg_statio_all_tables
  where heap_blks_hit + heap_blks_read > 0
  and schemaname not in ('pg_catalog','information_schema')
  order by 3;

\qecho <br>
\qecho cach read hit per index
\qecho <br>

SELECT schemaname,relname as table_name,indexrelname as index_name ,
 round((idx_blks_hit::numeric / (idx_blks_hit + idx_blks_read)::numeric)*100,2) as read_hit_percentage
FROM
  pg_statio_all_indexes
  where idx_blks_hit + idx_blks_read > 0
  and schemaname not in ('pg_catalog','information_schema')
  order by 4;

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#3">Back to Configuration Statistics</a>
\qecho <br>


-- +----------------------------------------------------------------------------+
-- |      - Replication                                   -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="Replication"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Replication</b></font><hr align="left" width="460">
\qecho <br>

\qecho <h3> Active replication slots order by age_xmin:</h3>
select *,age(xmin) age_xmin,age(catalog_xmin) age_catalog_xmin
from pg_replication_slots
where active = true
order by age(xmin) desc;
\qecho <br>
\qecho <h3> Replication Slot Lag:</h3>
select slot_name,slot_type,database,active,
coalesce(round(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) / 1024 / 1024 , 2),0) AS Lag_MB_behind ,
coalesce(round(pg_wal_lsn_diff(pg_current_wal_lsn(), restart_lsn) / 1024 / 1024 / 1024, 2),0) AS Lag_GB_behind
from pg_replication_slots
order by Lag_MB_behind desc;
\qecho <br>
\qecho <h3> Inactive replication slots order by age_xmin::</h3>
select *,age(xmin) age_xmin,age(catalog_xmin) age_catalog_xmin
from pg_replication_slots where active = false order by age(xmin) desc;
\qecho <br>
\qecho <h3> Note:</h3>
\qecho <br>
\qecho <h3>Replication Parameters :</h3>
select
name as parameter_name,setting,unit,short_desc
FROM pg_catalog.pg_settings
WHERE name in ('wal_level','max_wal_senders','max_replication_slots',
'max_worker_processes','max_logical_replication_workers','wal_receiver_timeout',
'max_sync_workers_per_subscription','wal_receiver_status_interval','wal_retrieve_retry_interval' ) ;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#4">Back to Replication Statistics</a>
\qecho <br>

-- +----------------------------------------------------------------------------+
-- |      - Orphaned_prepared_transactions                   -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="Orphaned_prepared_transactions"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Orphaned prepared transactions</b></font><hr align="left" width="460">
\qecho <br>

SELECT gid, prepared, owner, database, transaction AS xmin
FROM pg_prepared_xacts
ORDER BY age(transaction) DESC;

\qecho <br>

\qecho <a  href="#0">Back to Main</a><p />

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#4">Back to Replication Statistics</a>
\qecho <br>

-- +----------------------------------------------------------------------------+
-- |      - vacuum and Statistics           -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="vacuum_Statistics"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Vacuum & Statistics</b></font><hr align="left" width="460">
\qecho <br>
\qecho <h3>Autovacuum Parameters:</h3>
\qecho <br>

SELECT * from pg_settings where category like 'Autovacuum';
\qecho <br>
SELECT *  FROM pg_settings where name in ('rds.force_autovacuum_logging_level','log_autovacuum_min_duration') order by category;
\qecho <br>

-- currnt running  vacuum porecess
\qecho <br>
\qecho <h3>currnt running autovacuum porecess:</h3>
\qecho <br>

SELECT datname,usename,state,query,now() - pg_stat_activity.query_start AS duration, wait_event from pg_stat_activity where query like 'autovacuum:%' order by 4;

\qecho <br>
--  Whenever VACUUM is running, the pg_stat_progress_vacuum view will contain one row for each backend (including autovacuum worker processes) that is currently vacuuming (vacuum porgress)
\qecho <h3>Vacuum porgress:</h3>
\qecho <br>

SELECT p.pid, now() - a.xact_start AS duration, coalesce(wait_event_type ||'.'|| wait_event, 'f') AS waiting, CASE WHEN a.query ~ '^autovacuum.*to prevent wraparound' THEN 'wraparound' WHEN a.query ~ '^vacuum' THEN 'user' ELSE 'regular' END AS mode, p.datname AS database, p.relid::regclass AS table, p.phase, pg_size_pretty(p.heap_blks_total * current_setting('block_size')::int) AS table_size, pg_size_pretty(pg_total_relation_size(relid)) AS total_size, pg_size_pretty(p.heap_blks_scanned * current_setting('block_size')::int) AS scanned, pg_size_pretty(p.heap_blks_vacuumed * current_setting('block_size')::int) AS vacuumed, round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 1) AS scanned_pct, round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 1) AS vacuumed_pct, p.index_vacuum_count, round(100.0 * p.num_dead_tuples / p.max_dead_tuples,1) AS dead_pct FROM pg_stat_progress_vacuum p JOIN pg_stat_activity a using (pid) ORDER BY now() - a.xact_start DESC;

\qecho <br>
\qecho <h3>Autovacuum progress per day: </h3>
\qecho <br>

select to_char(last_autovacuum, 'YYYY-MM-DD') , count(*) from pg_stat_all_tables   group by to_char(last_autovacuum, 'YYYY-MM-DD') order by 1;

\qecho <br>
\qecho <h3>Autoanalyze progress per day: </h3>
\qecho <br>

select to_char(last_autoanalyze, 'YYYY-MM-DD') , count(*) from pg_stat_all_tables   group by to_char(last_autoanalyze, 'YYYY-MM-DD') order by 1;

\qecho <br>
--Which tables are currently eligible for autovacuum based on curret parameters
\qecho <h3>Which tables are currently eligible for autovacuum based on curret parameters : </h3>
\qecho <br>

WITH vbt AS (SELECT setting AS autovacuum_vacuum_threshold FROM pg_settings WHERE name = 'autovacuum_vacuum_threshold')
    , vsf AS (SELECT setting AS autovacuum_vacuum_scale_factor FROM pg_settings WHERE name = 'autovacuum_vacuum_scale_factor')
    , fma AS (SELECT setting AS autovacuum_freeze_max_age FROM pg_settings WHERE name = 'autovacuum_freeze_max_age')
    , sto AS (select opt_oid, split_part(setting, '=', 1) as param, split_part(setting, '=', 2) as value from (select oid opt_oid, unnest(reloptions) setting from pg_class) opt)
SELECT
    '"'||ns.nspname||'"."'||c.relname||'"' as relation
    , pg_size_pretty(pg_table_size(c.oid)) as table_size
    , age(relfrozenxid) as xid_age
    , coalesce(cfma.value::float, autovacuum_freeze_max_age::float) autovacuum_freeze_max_age
    , (coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float,autovacuum_vacuum_scale_factor::float) * c.reltuples) as autovacuum_vacuum_tuples
    , n_dead_tup as dead_tuples
FROM pg_class c join pg_namespace ns on ns.oid = c.relnamespace
join pg_stat_all_tables stat on stat.relid = c.oid
join vbt on (1=1) join vsf on (1=1) join fma on (1=1)
left join sto cvbt on cvbt.param = 'autovacuum_vacuum_threshold' and c.oid = cvbt.opt_oid
left join sto cvsf on cvsf.param = 'autovacuum_vacuum_scale_factor' and c.oid = cvsf.opt_oid
left join sto cfma on cfma.param = 'autovacuum_freeze_max_age' and c.oid = cfma.opt_oid
WHERE c.relkind = 'r' and nspname <> 'pg_catalog'
and (
    age(relfrozenxid) >= coalesce(cfma.value::float, autovacuum_freeze_max_age::float)
    or
    coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float,autovacuum_vacuum_scale_factor::float) * c.reltuples <= n_dead_tup
   -- or 1 = 1
)
ORDER BY age(relfrozenxid) DESC LIMIT 50;

\qecho <br>
-- check if the statistics collector is enabled (track_counts is on)
\qecho <h3>Check if the statistics collector is enabled (track_counts is on) : </h3>
\qecho <br>

SELECT name, setting FROM pg_settings WHERE name='track_counts';

\qecho <br>
-- to check the number of dead rows for the top 50 table
\qecho <h3>Number of dead rows for the top 50 table : </h3>
\qecho <br>

select relname,n_live_tup, n_tup_upd, n_tup_del, n_dead_tup, last_vacuum, last_autovacuum, last_analyze, last_autoanalyze  from pg_stat_all_tables order by n_dead_tup desc limit 50;

\qecho <br>
\qecho <h3>Tables have more than 20% dead rows :</h3>
\qecho <br>

select schemaname,relname , last_vacuum,last_autovacuum,n_live_tup,n_dead_tup , trunc((n_dead_tup::numeric/nullif(n_live_tup+n_dead_tup,0))* 100,2) as "n_dead_tup_%" from pg_stat_user_tables where n_dead_tup::float/nullif(n_live_tup+n_dead_tup,0) >.2 order by n_live_tup desc ;

\qecho <br>
\qecho <h3>pg_stat_all_tables : </h3>
\qecho <br>

select relname,schemaname,last_vacuum,last_autovacuum,last_analyze,last_autoanalyze,vacuum_count,autovacuum_count,analyze_count,autoanalyze_count from pg_stat_all_tables  where schemaname not in ('pg_catalog','pg_toast') order by 2;

\qecho <br>
\qecho <h3>pg_stat_all_tables order by autovacuum_count : </h3>
\qecho <br>

select relname,schemaname,last_vacuum,last_autovacuum,last_analyze,last_autoanalyze,vacuum_count,autovacuum_count,analyze_count,autoanalyze_count from pg_stat_all_tables  where schemaname not in ('pg_catalog','pg_toast') order by autovacuum_count desc;

\qecho <br>
\qecho <h3>pg_stat_all_tables order by autoanalyze_count: </h3>
\qecho <br>

select relname,schemaname,last_vacuum,last_autovacuum,last_analyze,last_autoanalyze,vacuum_count,autovacuum_count,analyze_count,autoanalyze_count from pg_stat_all_tables  where schemaname not in ('pg_catalog','pg_toast') order by autoanalyze_count desc;

\qecho <br>
\qecho <h3>tables without auto analyze : </h3>
\qecho <br>

select count(*) from pg_stat_all_tables  where  autoanalyze_count = 0 ;
\qecho <br>
select relname,schemaname,last_vacuum,last_autovacuum,autovacuum_count,autoanalyze_count,last_analyze,last_autoanalyze,n_mod_since_analyze from pg_stat_all_tables  where  autoanalyze_count = 0  order by 2;

\qecho <br>
\qecho <h3>tables without auto vacuum : </h3>
\qecho <br>

select count(*) from pg_stat_all_tables  where autovacuum_count  = 0 ;
\qecho <br>
select relname,schemaname,last_vacuum,last_autovacuum,autovacuum_count,autoanalyze_count,last_analyze,last_autoanalyze,n_dead_tup from pg_stat_all_tables  where autovacuum_count  = 0  order by 2;

\qecho <br>
\qecho <h3>Tables that have not been manually analyzed :</h3>
\qecho <br>

select count (analyze_count) from pg_stat_all_tables where analyze_count = 0;
\qecho <br>
select relname,schemaname,last_vacuum,vacuum_count,last_autovacuum,autovacuum_count,last_autoanalyze,autoanalyze_count,last_analyze,analyze_count from pg_stat_all_tables  where analyze_count = 0;

\qecho <br>
\qecho <h3>tables without auto analyze,auto vacuum,vacuum and analyze : </h3>
\qecho <br>

select count (*) from pg_stat_all_tables  where  autoanalyze_count = 0 and autovacuum_count  = 0 and analyze_count = 0 and vacuum_count=0 ;
\qecho <br>
select relname,schemaname,last_vacuum,vacuum_count,last_autovacuum,autovacuum_count,last_autoanalyze,autoanalyze_count,last_analyze,analyze_count from pg_stat_all_tables  where  autoanalyze_count = 0 and autovacuum_count  = 0 and analyze_count = 0 and vacuum_count=0 ;

\qecho <br>
-- to show tables that have specific table-level parameters set
\qecho <h3>Tables that have specific table-level parameters set : </h3>
\qecho <br>

select relname, reloptions from pg_class where reloptions is not null;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#5">Back to Vacuum and Wraparound Statistics</a>
\qecho <br>




-- +----------------------------------------------------------------------------+
-- |      - Transaction ID TXID                                   -             |
-- +----------------------------------------------------------------------------+


\qecho <a name="Transaction_ID_TXID"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Transaction ID TXID (Wraparound)</b></font><hr align="left" width="460">
\qecho <br>

\qecho <h3>oldest xid:</h3>

SELECT max(age(datfrozenxid)) oldest_xid FROM pg_database;


\qecho <h3>oldest xid per database:</h3>

SELECT datname database_name ,age(datfrozenxid) oldest_xid_per_DB
FROM pg_database order by 2 limit 20;


\qecho <h3 style="color:#FF0000;">percent_towards_emergency_autovac & percent_towards_wraparound :</h3>

WITH max_age AS ( SELECT 2000000000 as max_old_xid , setting AS
autovacuum_freeze_max_age FROM pg_catalog.pg_settings
WHERE name = 'autovacuum_freeze_max_age' ) ,
per_database_stats AS ( SELECT datname , m.max_old_xid::int ,
m.autovacuum_freeze_max_age::int , age(d.datfrozenxid) AS oldest_xid
FROM pg_catalog.pg_database d JOIN max_age m ON (true) WHERE d.datallowconn )
SELECT max(oldest_xid) AS oldest_xid ,
max(ROUND(100*(oldest_xid/max_old_xid::float))) AS percent_towards_wraparound
 , max(ROUND(100*(oldest_xid/autovacuum_freeze_max_age::float))) AS percent_towards_emergency_autovac
 FROM per_database_stats ;


\qecho <h3>current running autovacuum process:</h3>

SELECT datname,usename,state,query,
now() - pg_stat_activity.query_start AS duration,
wait_event from pg_stat_activity where query like 'autovacuum:%' order by 4;



\qecho <h3>current running vacuum process:</h3>

SELECT datname,usename,state,query,
now() - pg_stat_activity.query_start AS duration,
 wait_event from pg_stat_activity where query like 'vacuum:%' order by 4;


\qecho <h3>vacuum progress process:</h3>

SELECT p.pid, now() - a.xact_start AS duration, coalesce(wait_event_type ||'.'|| wait_event, 'f') AS waiting,
  CASE WHEN a.query ~ '^autovacuum.*to prevent wraparound' THEN 'wraparound' WHEN a.query ~ '^vacuum' THEN 'user' ELSE 'regular' END AS mode,
  p.datname AS database, p.relid::regclass AS table, p.phase, a.query ,
  pg_size_pretty(p.heap_blks_total * current_setting('block_size')::int) AS table_size,
  pg_size_pretty(pg_total_relation_size(p.relid)) AS total_size,
  pg_size_pretty(p.heap_blks_scanned * current_setting('block_size')::int) AS scanned,
  pg_size_pretty(p.heap_blks_vacuumed * current_setting('block_size')::int) AS vacuumed,
  round(100.0 * p.heap_blks_scanned / p.heap_blks_total, 1) AS scanned_pct,
  round(100.0 * p.heap_blks_vacuumed / p.heap_blks_total, 1) AS vacuumed_pct,
  p.index_vacuum_count,
  p.max_dead_tuples as max_dead_tuples_per_cycle,
  s.n_dead_tup as total_num_dead_tuples ,
  ceil(s.n_dead_tup::float/p.max_dead_tuples::float) index_cycles_required
FROM pg_stat_progress_vacuum p JOIN pg_stat_activity a using (pid)
     join pg_stat_all_tables s on s.relid = p.relid
ORDER BY now() - a.xact_start DESC;



\qecho <h3>Inactive replication slots order by age_xmin:</h3>

select *,age(xmin) age_xmin,age(catalog_xmin) age_catalog_xmin
from pg_replication_slots where active = false order by age(xmin) desc;


\qecho <h3>active replication slots order by age_xmin:</h3>

select *,age(xmin) age_xmin,age(catalog_xmin) age_catalog_xmin
from pg_replication_slots
where active = true
order by age(xmin) desc;


\qecho <h3>Orphaned prepared transactions:</h3>

SELECT gid, prepared, owner, database, age(transaction) AS ag_xmin
FROM pg_prepared_xacts
ORDER BY age(transaction) DESC;

\qecho <h3>MAX XID held:</h3>
SELECT
(SELECT max(age(backend_xmin)) FROM pg_stat_activity) as oldest_running_xact,
(SELECT max(age(transaction)) FROM pg_prepared_xacts) as oldest_prepared_xact,
(SELECT max(age(xmin)) FROM pg_replication_slots) as oldest_replication_slot,
(SELECT max(age(backend_xmin))FROM pg_stat_replication)as oldest_replica_xact;


--\qecho <h3>XID Rate:</h3>


--SELECT max(age(datfrozenxid)) as xid1 FROM pg_database \gset
--select pg_sleep(60);
--SELECT max(age(datfrozenxid)) as xid2 FROM pg_database \gset
--select txid_current() current_txid \gset


--select (select :xid2 - :xid1)as XID_Rate,(2000000000-:current_txid) as Remaining_XIDs,
--(2000000000-:current_txid)/ ( select :xid2 - :xid1 ) /10/3600 hours_before_wraparound_prevention,
--(2000000000-:current_txid)/ ( select :xid2 - :xid1 ) /10/3600/24 days_before_wraparound_prevention
--;


\qecho <h3>Autovacuum , vacuum and maintenance_work_mem Parameters:</h3>


SELECT name,setting,source,sourcefile from pg_settings where name like '%vacuum%' order by 1;
SELECT name,setting,source,sourcefile from pg_settings where name ='maintenance_work_mem';




\qecho <h3>Which tables are currently eligible for autovacuum ? </h3>

WITH vbt AS (SELECT setting AS autovacuum_vacuum_threshold FROM pg_settings WHERE name = 'autovacuum_vacuum_threshold')
    , vsf AS (SELECT setting AS autovacuum_vacuum_scale_factor FROM pg_settings WHERE name = 'autovacuum_vacuum_scale_factor')
    , fma AS (SELECT setting AS autovacuum_freeze_max_age FROM pg_settings WHERE name = 'autovacuum_freeze_max_age')
    , sto AS (select opt_oid, split_part(setting, '=', 1) as param, split_part(setting, '=', 2) as value from (select oid opt_oid, unnest(reloptions) setting from pg_class) opt)
SELECT
    '"'||ns.nspname||'"."'||c.relname||'"' as relation
    , pg_size_pretty(pg_table_size(c.oid)) as table_size
    , age(relfrozenxid) as xid_age
    , coalesce(cfma.value::float, autovacuum_freeze_max_age::float) autovacuum_freeze_max_age
    , (coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float,autovacuum_vacuum_scale_factor::float) * c.reltuples) as autovacuum_vacuum_tuples
    , n_dead_tup as dead_tuples
FROM pg_class c join pg_namespace ns on ns.oid = c.relnamespace
join pg_stat_all_tables stat on stat.relid = c.oid
join vbt on (1=1) join vsf on (1=1) join fma on (1=1)
left join sto cvbt on cvbt.param = 'autovacuum_vacuum_threshold' and c.oid = cvbt.opt_oid
left join sto cvsf on cvsf.param = 'autovacuum_vacuum_scale_factor' and c.oid = cvsf.opt_oid
left join sto cfma on cfma.param = 'autovacuum_freeze_max_age' and c.oid = cfma.opt_oid
WHERE c.relkind = 'r' and nspname <> 'pg_catalog'
and (
    age(relfrozenxid) >= coalesce(cfma.value::float, autovacuum_freeze_max_age::float)
    or
    coalesce(cvbt.value::float, autovacuum_vacuum_threshold::float) + coalesce(cvsf.value::float,autovacuum_vacuum_scale_factor::float) * c.reltuples <= n_dead_tup
   -- or 1 = 1
)
ORDER BY age(relfrozenxid) DESC ;


\qecho <h3>autovacuum progress per day:</h3>

select to_char(last_autovacuum, 'YYYY-MM-DD') as date,
count(*) from pg_stat_all_tables
group by to_char(last_autovacuum, 'YYYY-MM-DD') order by 1;



\qecho <h3>when the last autovacuum succeeded ?</h3>

select relname as table_name,n_live_tup, n_tup_upd, n_tup_del, n_dead_tup,
last_vacuum, last_autovacuum, last_analyze, last_autoanalyze
from pg_stat_all_tables
order by last_autovacuum desc limit 20 ;




\qecho <h3>Top-20 tables order by xid age:</h3>

-- this need to be run in each DB in the instance

SELECT c.oid::regclass as relation_name,
        greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age,
        pg_size_pretty(pg_table_size(c.oid)) as table_size,
        c.relkind
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind in ('r', 't','m')
order by 2 desc limit 20;



\qecho <h3>indexs inforamtion for Top-20 tables order by xid age:</h3>

SELECT schemaname,relname AS tablename,
indexrelname AS indexname,
idx_scan ,
pg_relation_size(indexrelid) as index_size,
pg_size_pretty(pg_relation_size(indexrelid)) AS pretty_index_size
FROM pg_catalog.pg_stat_all_indexes
WHERE  relname in (select relation_name::text from (SELECT c.oid::regclass as relation_name,
        greatest(age(c.relfrozenxid),age(t.relfrozenxid)) as age,
        pg_size_pretty(pg_table_size(c.oid)) as table_size,
        c.relkind
FROM pg_class c
LEFT JOIN pg_class t ON c.reltoastrelid = t.oid
WHERE c.relkind in ('r', 't','m')
order by 2 desc limit 20) as r1 )
order by 2,4 ;



\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#5">Back to Vacuum and Wraparound Statistics</a>
\qecho <br>

-- +----------------------------------------------------------------------------+
-- |      - Multixact ID MXID                                -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="Multixact_ID_MXID"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Multixact ID MXID (Wraparound)</b></font><hr align="left" width="460">
\qecho <br>

\qecho <h3>oldest mxid::</h3>
SELECT max(mxid_age(datminmxid)) oldest_mxid FROM pg_database ;

\qecho <h3>oldest mxid per database:</h3>
SELECT datname database_name , mxid_age(datminmxid) oldest_mxid FROM pg_database order by 2 desc;

\qecho <h3>autovacuum_multixact_freeze_max_age parameter value:</h3>

select setting AS autovacuum_multixact_freeze_max_age FROM pg_catalog.pg_settings WHERE name = 'autovacuum_multixact_freeze_max_age';

\qecho <h3>Top-20 tables order by MXID age:</h3>


select relname as table_name ,mxid_age(relminmxid) mmxid_age from pg_class where relname not like 'pg_toast%'
and relminmxid::text::int>0
order by 2 desc limit 20;

\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#5">Back to Vacuum and Wraparound Statistics</a>
\qecho <br>




-- +----------------------------------------------------------------------------+
-- |      - pg_stat_statements extension                                    -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="pg_stat_statements_extension"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>pg_stat_statements extension</b></font><hr align="left" width="460">
\qecho <br>
\qecho <h3> pg_stat_statements installed version: </h3>
\qecho <br>

SELECT e.extname AS "Extension Name", e.extversion AS "Version", n.nspname AS "Schema",pg_get_userbyid(e.extowner)  as Owner, c.description AS "Description" , e.extrelocatable as "relocatable to another schema", e.extconfig ,e.extcondition
 FROM pg_catalog.pg_extension e LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid AND c.classoid = 'pg_catalog.pg_extension'::pg_catalog.regclass
 where e.extname = 'pg_stat_statements';
\qecho <br>
\qecho <h3>Parameters values: </h3>
-- pg_stat_statements extension configuration
select name as parameter_name, setting  from pg_settings where name in ('pg_stat_statements.track','pg_stat_statements.track_utility','pg_stat_statements.save'
,'pg_stat_statements.max','shared_preload_libraries');
\qecho <br>
\qecho <h3>Available versions that are available to upgrade: </h3>
select * from
(
select b.name as extension_name , b.version as version ,b.installed as installed
from
(SELECT extname ,extversion FROM pg_extension) a ,
(SELECT name ,version ,installed FROM pg_available_extension_versions where name in (SELECT extname FROM pg_extension)) b
where a.extname = b.name
and b.version > a.extversion
order by b.name , b.version
) as r
where r.extension_name='pg_stat_statements';
;
\qecho <br>
\qecho <h3>Latest Extension version that is available to upgrade: </h3>
select * from
(
select name as extension_name , max(version) as latest_version
from
(select b.name , b.version ,b.installed
from
(SELECT extname ,extversion FROM pg_extension) a ,
(SELECT name ,version ,installed FROM pg_available_extension_versions where name in (SELECT extname FROM pg_extension)) b
where a.extname = b.name
and b.version > a.extversion
order by b.name , b.version ) e
group by name
) as r
where r.extension_name='pg_stat_statements';
;


\qecho <br>
\qecho <h3> Top SQL order by total_time: </h3>
\qecho <br>

--Top SQL order by total_time
select queryid,substring(query,1,60) as query , calls,
round(total_time::numeric, 2) as total_time_Msec,
round((total_time::numeric/1000), 2) as total_time_sec,
round(mean_time::numeric,2) as avg_time_Msec,
round((mean_time::numeric/1000),2) as avg_time_sec,
round(stddev_time::numeric, 2) as standard_deviation_time_Msec,
round((stddev_time::numeric/1000), 2) as standard_deviation_time_sec,
round(rows::numeric/calls,2) rows_per_exec,
round((100 * total_time / sum(total_time) over ())::numeric, 4) as percent
from pg_stat_statements
order by total_time_Msec desc limit 20;


\qecho <br>
\qecho <h3> Top SQL order by avg_time: </h3>
\qecho <br>

--Top SQL order by avg_time
select queryid,substring(query,1,60) as query , calls,
round(total_time::numeric, 2) as total_time_Msec,
round((total_time::numeric/1000), 2) as total_time_sec,
round(mean_time::numeric,2) as avg_time_Msec,
round((mean_time::numeric/1000),2) as avg_time_sec,
round(stddev_time::numeric, 2) as standard_deviation_time_Msec,
round((stddev_time::numeric/1000), 2) as standard_deviation_time_sec,
round(rows::numeric/calls,2) rows_per_exec,
round((100 * total_time / sum(total_time) over ())::numeric, 4) as percent
from pg_stat_statements
order by avg_time_Msec desc limit 20;


\qecho <br>
\qecho <h3> Top SQL order by percent of total DB time percent: </h3>
\qecho <br>

--Top SQL order by percent of total DB time
select queryid,substring(query,1,60) as query , calls,
round(total_time::numeric, 2) as total_time_Msec,
round((total_time::numeric/1000), 2) as total_time_sec,
round(mean_time::numeric,2) as avg_time_Msec,
round((mean_time::numeric/1000),2) as avg_time_sec,
round(stddev_time::numeric, 2) as standard_deviation_time_Msec,
round((stddev_time::numeric/1000), 2) as standard_deviation_time_sec,
round(rows::numeric/calls,2) rows_per_exec,
round((100 * total_time / sum(total_time) over ())::numeric, 4) as percent
from pg_stat_statements
order by percent desc limit 20;


\qecho <br>
\qecho <h3> Top SQL order by number of execution (CALLs): </h3>
\qecho <br>

--Top SQL order by number of execution (CALLs)
select queryid,substring(query,1,60) as query , calls,
round(total_time::numeric, 2) as total_time_Msec,
round((total_time::numeric/1000), 2) as total_time_sec,
round(mean_time::numeric,2) as avg_time_Msec,
round((mean_time::numeric/1000),2) as avg_time_sec,
round(stddev_time::numeric, 2) as standard_deviation_time_Msec,
round((stddev_time::numeric/1000), 2) as standard_deviation_time_sec,
round(rows::numeric/calls,2) rows_per_exec,
round((100 * total_time / sum(total_time) over ())::numeric, 4) as percent
from pg_stat_statements
order by calls desc limit 20;


\qecho <br>
\qecho <h3> Top SQL order by shared blocks read (physical reads): </h3>
\qecho <br>

--Top SQL order by shared blocks read (physical reads)
select queryid, substring(query,1,60) as query , calls,
round(total_time::numeric, 2) as total_time_Msec,
round((total_time::numeric/1000), 2) as total_time_sec,
round(mean_time::numeric,2) as avg_time_Msec,
round((mean_time::numeric/1000),2) as avg_time_sec,
round(stddev_time::numeric, 2) as standard_deviation_time_Msec,
round((stddev_time::numeric/1000), 2) as standard_deviation_time_sec,
round(rows::numeric/calls,2) rows_per_exec,
round((100 * total_time / sum(total_time) over ())::numeric, 4) as percent,
shared_blks_read
from pg_stat_statements
order by shared_blks_read desc limit 20;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#6">Back to Extension Statistics</a>
\qecho <br>


-- +----------------------------------------------------------------------------+
-- |      - pgaudit_extension                                  -                |
-- +----------------------------------------------------------------------------+


\qecho <a name="pgaudit_extension"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>pgaudit extension</b></font><hr align="left" width="460">
\qecho <br>

SELECT e.extname AS "Extension Name", e.extversion AS "Version", n.nspname AS "Schema",pg_get_userbyid(e.extowner)  as Owner, c.description AS "Description" , e.extrelocatable as "relocatable to another schema", e.extconfig ,e.extcondition
 FROM pg_catalog.pg_extension e LEFT JOIN pg_catalog.pg_namespace n ON n.oid = e.extnamespace LEFT JOIN pg_catalog.pg_description c ON c.objoid = e.oid AND c.classoid = 'pg_catalog.pg_extension'::pg_catalog.regclass
 where e.extname = 'pgaudit';
\qecho <br>
SELECT name as "parameter_name", setting from pg_settings where name like 'pgaudit.%' or name = 'shared_preload_libraries';
\qecho <br>
\qecho <h3>pgaudit user level configuration : </h3>
select usename as user_name,useconfig as user_config FROM pg_user where useconfig::text like '%pgaudit.%';




\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#6">Back to Extension Statistics</a>
\qecho <br>



-- +----------------------------------------------------------------------------+
-- |      - sessions_info                                                     - |
-- +----------------------------------------------------------------------------+

\qecho <a name="sessions_info"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>Sessions/Connections Info</b></font><hr align="left" width="460">
\qecho <br>

\qecho <h3>Connections utilization:</h3>
with
settings as (SELECT setting::float AS "max_connections" FROM pg_settings WHERE name = 'max_connections'),
connections as (select sum (numbackends)::float total_connections from pg_stat_database)
select   settings.max_connections AS "Max_connections" ,total_connections as "Total_connections",ROUND((100*(connections.Total_connections/settings.max_connections))::numeric,2) as "Connections utilization %" from  settings, connections;
\qecho <h3> DB/Connections count :</h3>
SELECT datname as "Database_Name",count(*) as "Connections_count" FROM pg_stat_activity where datname is not null group by datname order by 2 desc;
\qecho <h3> DB/username/Connections count :</h3>
SELECT datname as "Database_Name",usename as "User_Name" ,count(*) as "Connections_count" FROM pg_stat_activity  where datname is not null  group by datname,usename order by 1,3 desc;
\qecho <h3> username/Connections count :</h3>
SELECT usename as "User_Name",count(*) as "connections_count" FROM pg_stat_activity  where datname is not null  group by usename order by 2 desc;
\qecho <h3> username/status/Connections count :</h3>
SELECT usename as "User_Name",state as status,count(*) as "Connections_count" FROM pg_stat_activity  where datname is not null group by usename,state order by 1,2 desc;
\qecho <h3> status/Connections count :</h3>
SELECT state as status ,count(*) as "Connections_count" FROM pg_stat_activity where datname is not null GROUP BY status order by 2 desc;
\qecho <h3> username/status/SQL/count : </h3>
SELECT usename as "User_Name" , state as status , query, count(*) FROM pg_stat_activity where datname is not null group by usename,state,query ;


\qecho <br>
\qecho <h3>Active sessions:</h3>
\qecho <br>

/* active_session_monitor*/ select * from
(
    SELECT
usename,pid, now() - pg_stat_activity.xact_start AS xact_duration ,now() - pg_stat_activity.query_start AS query_duration,
substr(query,1,50) as query,state,wait_event
FROM pg_stat_activity
) as s where (xact_duration is not null  or query_duration is not null ) and state!='idle' and query not like '%active_session_monitor%'
order by xact_duration desc, query_duration desc;


\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#7">Back to Current Workload Statistics</a>
\qecho <br>




-- +----------------------------------------------------------------------------+
-- |      - DB_Load                                          -                  |
-- +----------------------------------------------------------------------------+


\qecho <a name="DB_Load"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>DB Load</b></font><hr align="left" width="460">
\qecho <br>
\qecho <h3>How many session waiting on CPU and None CPU wait event:</h3>

select coalesce(count(*),'0') as  count_of_sessions_waiting_on_CPU
FROM pg_stat_activity
where wait_event is null and state = 'active' group by wait_event ;
\qecho <br>
select coalesce(sum(count),'0') as count_of_sessions_waiting_on_None_CPU
from (SELECT count(*) as count
FROM pg_stat_activity
where wait_event is not null and state = 'active'
group by wait_event) as c;


\qecho <br>
\qecho <h3>wait events:</h3>

\qecho <h3>wait events/session count :</h3>
SELECT coalesce(wait_event,'CPU') as wait_event , count(*) FROM pg_stat_activity group by wait_event order by 2 desc;
\qecho <br>
\qecho <h3>wait events/query  :</h3>
SELECT  coalesce(wait_event,'CPU') as wait_event, substr(query,1,150) as query,count(*) FROM pg_stat_activity   group by  query,wait_event order by 3 desc;
\qecho <br>
\qecho <h3>wait events/user name :</h3>
SELECT coalesce(wait_event,'CPU') wait_event,usename as user_name, count(*) FROM pg_stat_activity group by wait_event, usename order by 3 desc ;



\qecho <br>
\qecho <h3>Lock :</h3>

\qecho <br>
\qecho <h3>Not granted lock :</h3>
SELECT coalesce(count(*),0) as "not_granted_lock" FROM pg_locks WHERE NOT GRANTED;
\qecho <br>
\qecho <h3>blocked sessions :</h3>
select count(*) from pg_stat_activity where cardinality(pg_blocking_pids(pid)) > 0 ;
\qecho <br>
\qecho <h3>lock_mode :</h3>
SELECT mode as lock_mode , count(*) FROM pg_locks group by mode;
\qecho <br>
\qecho <h3>lock_type :</h3>
SELECT locktype as lock_type , count(*) FROM pg_locks group by locktype;



\qecho <br>
\qecho <h3>pg_stat_* views:</h3>

\qecho <br>
\qecho <h3>pg_stat_bgwriter view:</h3>
select * from pg_stat_bgwriter;
\qecho <br>
\qecho <h3>pg_stat_database view:</h3>
select * from pg_stat_database;
\qecho <br>
\qecho <h3>pg_stat_database_conflicts view:</h3>
select * from pg_stat_database_conflicts;



\qecho <br>
\qecho <a  href="#0">Back to Main</a><p />
\qecho <a  href="#7">Back to Current Workload Statistics</a>
\qecho <br>

\qecho <a name="-----"></a>
\qecho <font size="+2" face="Arial,Helvetica,Geneva,sans-serif" color="#336699"><b>*****</b></font><hr align="left" width="460">
\qecho <br>

-- sql


\qecho <a  href="#0">Back to Main</a><p />

\q
